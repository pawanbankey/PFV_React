{"version":3,"sources":["PathfinderVisualizer/Node/Node.jsx","algorithms/dj.js","PathfinderVisualizer/PathfinderVisualizer.jsx","App.js","index.js"],"names":["Node","Component","render","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","this","props","extraClassName","_jsx","id","concat","className","sortNodesByDistance","unvisited","sort","nodeA","nodeB","distance","updateUnvisitedNeighbors","node","grid","unvisitedNeighbors","neighbors","push","length","filter","neighbor","isVisited","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","constructor","super","state","mouseIsPressed","componentDidMount","getInitialGrid","setState","handleMouseDown","newGrid","getNewGridWithWallToggled","handleMouseEnter","handleMouseUp","animateDijkstra","visitedNodesInOrder","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","visualizeDijkstra","startNode","finishNode","start","end","visited","nodes","getAllNodes","closest","shift","Infinity","dijkstra","currentNode","unshift","getNodesInShortestPathOrder","_jsxs","_Fragment","children","onClick","map","rowIdx","nodeIdx","currentRow","createNode","slice","newNode","App","PathfinderVisualizer","ReactDOM","React","StrictMode"],"mappings":"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","file":"static/js/main.38383246.chunk.js","sourcesContent":["import React, {Component} from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n      ? 'node-start'\n      : isWall\n      ? 'node-wall'\n      : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}","export function dijkstra(grid, start, end) {\n    const visited = [];\n    start.distance = 0;\n    const unvisited = getAllNodes(grid);\n    while (!!unvisited.length) {\n      sortNodesByDistance(unvisited);\n      const closest = unvisited.shift();\n      // If we encounter a wall, we skip it.\n      if (closest.isWall) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closest.distance === Infinity) return visited;\n      closest.isVisited = true;\n      visited.push(closest);\n      if (closest === end) return visited;\n      updateUnvisitedNeighbors(closest, grid);\n    }\n  }\n  \n  function sortNodesByDistance(unvisited) {\n    unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n  }\n  \n  function updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n  \n  function getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n  }\n  \n  function getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n  }\n  \n  // Backtracks from the finishNode to find the shortest path.\n  // Only works when called *after* the dijkstra method above.\n  export function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n  }","import React, {Component} from 'react';\nimport Node from './Node/Node';\nimport {dijkstra, getNodesInShortestPathOrder} from '../algorithms/dj';\n\nimport './PathfinderVisualizer.css';\n\nconst START_NODE_ROW = 7;\nconst START_NODE_COL = 10;\nconst FINISH_NODE_ROW = 7;\nconst FINISH_NODE_COL = 30;\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({grid});\n  }\n\n  handleMouseDown(row, col) {\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid, mouseIsPressed: true});\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({grid: newGrid});\n  }\n\n  handleMouseUp() {\n    this.setState({mouseIsPressed: false});\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-visited';\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          'node node-shortest-path';\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const {grid} = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  render() {\n    const {grid, mouseIsPressed} = this.state;\n\n    return (\n      <>\n        <button className=\"Button\" onClick={() => this.visualizeDijkstra()}>\n          Visualize Dijkstra's Algorithm\n        </button>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {row, col, isFinish, isStart, isWall} = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\nconst getInitialGrid = () => {\n  const grid = [];\n  for (let row = 0; row < 16; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 40; col++) {\n      currentRow.push(createNode(col, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row) => {\n  return {\n    col,\n    row,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};","import React from 'react';\nimport './App.css';\nimport PathfinderVisualizer from './PathfinderVisualizer/PathfinderVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfinderVisualizer></PathfinderVisualizer>\n    </div>\n  );\n}\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}